package com.webcodepro.shrinkit.io;

import org.junit.Assert;

import junit.framework.AssertionFailedError;

/**
 * Some common testing methods.
 * 
 * @author robgreene@users.sourceforge.net
 */
public abstract class TestBase {
	/**
	 * Compare two byte arrays.
	 */
	public void assertEquals(byte[] expected, byte[] actual) {
		try {
			Assert.assertEquals("Length mismatch", expected.length, actual.length);
			for (int i=0; i<expected.length; i++) {
				Assert.assertEquals("Byte mismatch at offset " + i, expected[i], actual[i]);
			}
		} catch (AssertionFailedError err) {
			int minvalue = Math.min(expected.length, actual.length);
			for (int i=0; i<minvalue; i++) {
				Assert.assertEquals(err.getMessage() + " -- Byte mismatch at offset " + i, expected[i], actual[i]);
			}
			Assert.fail(err.getMessage() + " -- all bytes that could be compared match");
		}
	}
	/**
	 * Compare two int arrays.
	 */
	public void assertEquals(int[] expected, int[] actual) {
		try {
			Assert.assertEquals("Length mismatch", expected.length, actual.length);
			for (int i=0; i<expected.length; i++) {
				Assert.assertEquals("int mismatch at offset " + i, expected[i], actual[i]);
			}
		} catch (AssertionFailedError err) {
			int minvalue = Math.min(expected.length, actual.length);
			for (int i=0; i<minvalue; i++) {
				Assert.assertEquals(err.getMessage() + " -- Byte mismatch at offset " + i, expected[i], actual[i]);
			}
			Assert.fail(err.getMessage() + " -- all bytes that could be compared match");
		}
	}
	
	public byte[] getHgrColorsLzw1() {
		return new byte[] {
				(byte)0xdb, 0x00, 0x1c, (byte)0xd8, 0x56, 0x65, (byte)0xa0, (byte)0x8a, 
				(byte)0x81, 0x00, (byte)0xde, 0x6c, 0x3b, 0x48, 0x10, (byte)0xa1, 
				(byte)0xc2, 0x3f, 0x0f, 0x02, (byte)0xfe, (byte)0x93, 0x48, 0x11, 
				(byte)0xc0, 0x44, (byte)0x8b, 0x15, 0x2f, 0x6a, (byte)0xcc, (byte)0xc8, 
				0x11, 0x23, (byte)0x80, 0x73
			};
	}
	public int[] getHgrColorsUncompressed() {
		return new int[] {
				0xdb, 0x00, 0x07, 0xdb, 0x55, 0x07, 0xdb, 0x2a, 
				0x07, 0xdb, 0x00, 0x6f, 0xdb, 0x2a, 0x07, 0xdb, 
				0x55, 0x07, 0xdb, 0x00, 0x6f, 0xdb, 0x7f, 0x0f, 
				0xdb, 0x00, 0xff, 0xdb, 0x00, 0xff, 0xdb, 0x00, 
				0xff, 0xdb, 0x00, 0xff, 0xdb, 0x00, 0xff, 0xdb, 
				0x00, 0xff, 0xdb, 0x00, 0xff, 0xdb, 0x00, 0xff, 
				0xdb, 0x00, 0xff, 0xdb, 0x00, 0xff, 0xdb, 0x00, 
				0xff, 0xdb, 0x00, 0xff, 0xdb, 0x00, 0xff, 0xdb, 
				0x00, 0xff, 0xdb, 0x00, 0xe7
			};
	}
	public byte[] getTextFileLzw1() {
		return new byte[] {
				0x54, (byte)0x90, 0x24, (byte)0x99, 0x02, 0x62, 0x20, (byte)0x88, 
				(byte)0x80, 0x45, 0x40, 0x5C, 0x09, (byte)0x92, 0x45, 0x61, 
				(byte)0xC2, (byte)0x85, 0x53, (byte)0x90, (byte)0x80, 0x78, 0x52, 0x45, 
				0x0A, (byte)0x88, 0x21, 0x4C, (byte)0x9E, 0x20, (byte)0x9C, (byte)0xC2, 
				0x42, 0x61, (byte)0x90, (byte)0x88, 0x13, 0x2B, 0x5E, (byte)0xCC, 
				(byte)0xB8, (byte)0xB1, 0x23, 0x44, (byte)0x89, 0x14, 0x2D, 0x62, 
				(byte)0xD4, (byte)0x88, (byte)0xA4, (byte)0xC8, 0x14, 0x17, 0x20, 0x0E, 
				0x0A, 0x24, 0x68, 0x10, (byte)0xA1, (byte)0xC7, (byte)0x86, 0x57, 
				0x1E, 0x7E, 0x44, 0x29, 0x72, 0x65, 0x49, 0x10, 
				0x53, (byte)0x9E, (byte)0x80, 0x28, 0x12, 0x44, 0x0A, (byte)0x93, 
				(byte)0x86, 0x49, (byte)0x9C, (byte)0xC8, 0x4C, (byte)0xD8, (byte)0xE4, (byte)0x89, 
				0x14, 0x27, 0x49, (byte)0x8F, (byte)0xB8, (byte)0xD8, 0x06, (byte)0xE0, 
				0x1F, 0x55, (byte)0xAB, 0x55, (byte)0xAF, 0x6A, (byte)0xCD, (byte)0xCA, 
				0x15, (byte)0xAB, (byte)0xD7, (byte)0xAD, 0x5F, (byte)0xBB, 0x52, (byte)0xC5, 
				0x03, 0x00				
			};
	}
}
